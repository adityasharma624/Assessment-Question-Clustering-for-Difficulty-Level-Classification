{
  "basic": {
    "title": "Minimum Weighted Subgraph With the Required Paths",
    "titleSlug": "minimum-weighted-subgraph-with-the-required-paths",
    "frontendQuestionId": 2321,
    "acRate": null,
    "difficulty": {
      "level": 3
    },
    "paidOnly": false,
    "isFavor": false,
    "status": null
  },
  "detail": {
    "questionId": "2321",
    "title": "Minimum Weighted Subgraph With the Required Paths",
    "titleSlug": "minimum-weighted-subgraph-with-the-required-paths",
    "content": "<p>You are given an integer <code>n</code> denoting the number of nodes of a <strong>weighted directed</strong> graph. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there exists a <strong>directed</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with weight <code>weight<sub>i</sub></code>.</p>\n\n<p>Lastly, you are given three <strong>distinct</strong> integers <code>src1</code>, <code>src2</code>, and <code>dest</code> denoting three distinct nodes of the graph.</p>\n\n<p>Return <em>the <strong>minimum weight</strong> of a subgraph of the graph such that it is <strong>possible</strong> to reach</em> <code>dest</code> <em>from both</em> <code>src1</code> <em>and</em> <code>src2</code> <em>via a set of edges of this subgraph</em>. In case such a subgraph does not exist, return <code>-1</code>.</p>\n\n<p>A <strong>subgraph</strong> is a graph whose vertices and edges are subsets of the original graph. The <strong>weight</strong> of a subgraph is the sum of weights of its constituent edges.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png\" style=\"width: 263px; height: 250px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n<strong>Output:</strong> 9\n<strong>Explanation:</strong>\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png\" style=\"width: 350px; height: 51px;\" />\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>src1</code>, <code>src2</code>, and <code>dest</code> are pairwise distinct.</li>\n\t<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
    "difficulty": "Hard",
    "likes": 771,
    "dislikes": 23,
    "isPaidOnly": false,
    "sampleTestCase": "6\n[[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]]\n0\n1\n5",
    "codeSnippets": [
      {
        "lang": "C++",
        "langSlug": "cpp",
        "code": "class Solution {\npublic:\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\n        \n    }\n};"
      },
      {
        "lang": "Java",
        "langSlug": "java",
        "code": "class Solution {\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\n        \n    }\n}"
      },
      {
        "lang": "Python3",
        "langSlug": "python3",
        "code": "class Solution:\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n        "
      },
      {
        "lang": "Python",
        "langSlug": "python",
        "code": "class Solution(object):\n    def minimumWeight(self, n, edges, src1, src2, dest):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :type src1: int\n        :type src2: int\n        :type dest: int\n        :rtype: int\n        \"\"\"\n        "
      },
      {
        "lang": "JavaScript",
        "langSlug": "javascript",
        "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} src1\n * @param {number} src2\n * @param {number} dest\n * @return {number}\n */\nvar minimumWeight = function(n, edges, src1, src2, dest) {\n    \n};"
      },
      {
        "lang": "TypeScript",
        "langSlug": "typescript",
        "code": "function minimumWeight(n: number, edges: number[][], src1: number, src2: number, dest: number): number {\n    \n};"
      },
      {
        "lang": "C#",
        "langSlug": "csharp",
        "code": "public class Solution {\n    public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\n        \n    }\n}"
      },
      {
        "lang": "C",
        "langSlug": "c",
        "code": "long long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest) {\n    \n}"
      },
      {
        "lang": "Go",
        "langSlug": "golang",
        "code": "func minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\n    \n}"
      },
      {
        "lang": "Kotlin",
        "langSlug": "kotlin",
        "code": "class Solution {\n    fun minimumWeight(n: Int, edges: Array<IntArray>, src1: Int, src2: Int, dest: Int): Long {\n        \n    }\n}"
      },
      {
        "lang": "Swift",
        "langSlug": "swift",
        "code": "class Solution {\n    func minimumWeight(_ n: Int, _ edges: [[Int]], _ src1: Int, _ src2: Int, _ dest: Int) -> Int {\n        \n    }\n}"
      },
      {
        "lang": "Rust",
        "langSlug": "rust",
        "code": "impl Solution {\n    pub fn minimum_weight(n: i32, edges: Vec<Vec<i32>>, src1: i32, src2: i32, dest: i32) -> i64 {\n        \n    }\n}"
      },
      {
        "lang": "Ruby",
        "langSlug": "ruby",
        "code": "# @param {Integer} n\n# @param {Integer[][]} edges\n# @param {Integer} src1\n# @param {Integer} src2\n# @param {Integer} dest\n# @return {Integer}\ndef minimum_weight(n, edges, src1, src2, dest)\n    \nend"
      },
      {
        "lang": "PHP",
        "langSlug": "php",
        "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @param Integer $src1\n     * @param Integer $src2\n     * @param Integer $dest\n     * @return Integer\n     */\n    function minimumWeight($n, $edges, $src1, $src2, $dest) {\n        \n    }\n}"
      },
      {
        "lang": "Dart",
        "langSlug": "dart",
        "code": "class Solution {\n  int minimumWeight(int n, List<List<int>> edges, int src1, int src2, int dest) {\n    \n  }\n}"
      },
      {
        "lang": "Scala",
        "langSlug": "scala",
        "code": "object Solution {\n    def minimumWeight(n: Int, edges: Array[Array[Int]], src1: Int, src2: Int, dest: Int): Long = {\n        \n    }\n}"
      },
      {
        "lang": "Elixir",
        "langSlug": "elixir",
        "code": "defmodule Solution do\n  @spec minimum_weight(n :: integer, edges :: [[integer]], src1 :: integer, src2 :: integer, dest :: integer) :: integer\n  def minimum_weight(n, edges, src1, src2, dest) do\n    \n  end\nend"
      },
      {
        "lang": "Erlang",
        "langSlug": "erlang",
        "code": "-spec minimum_weight(N :: integer(), Edges :: [[integer()]], Src1 :: integer(), Src2 :: integer(), Dest :: integer()) -> integer().\nminimum_weight(N, Edges, Src1, Src2, Dest) ->\n  ."
      },
      {
        "lang": "Racket",
        "langSlug": "racket",
        "code": "(define/contract (minimum-weight n edges src1 src2 dest)\n  (-> exact-integer? (listof (listof exact-integer?)) exact-integer? exact-integer? exact-integer? exact-integer?)\n  )"
      }
    ],
    "topicTags": [
      {
        "name": "Graph",
        "slug": "graph",
        "translatedName": null
      },
      {
        "name": "Shortest Path",
        "slug": "shortest-path",
        "translatedName": null
      }
    ],
    "stats": "{\"totalAccepted\": \"18.9K\", \"totalSubmission\": \"47.6K\", \"totalAcceptedRaw\": 18947, \"totalSubmissionRaw\": 47585, \"acRate\": \"39.8%\"}",
    "similarQuestions": "[{\"title\": \"Minimum Cost to Make at Least One Valid Path in a Grid\", \"titleSlug\": \"minimum-cost-to-make-at-least-one-valid-path-in-a-grid\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Escape the Spreading Fire\", \"titleSlug\": \"escape-the-spreading-fire\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Disconnect Path in a Binary Matrix by at Most One Flip\", \"titleSlug\": \"disconnect-path-in-a-binary-matrix-by-at-most-one-flip\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
    "stats_parsed": {
      "totalAccepted": "18.9K",
      "totalSubmission": "47.6K",
      "totalAcceptedRaw": 18947,
      "totalSubmissionRaw": 47585,
      "acRate": "39.8%"
    },
    "similarQuestions_parsed": [
      {
        "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
        "titleSlug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "difficulty": "Hard",
        "translatedTitle": null
      },
      {
        "title": "Escape the Spreading Fire",
        "titleSlug": "escape-the-spreading-fire",
        "difficulty": "Hard",
        "translatedTitle": null
      },
      {
        "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
        "titleSlug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "difficulty": "Medium",
        "translatedTitle": null
      }
    ]
  },
  "discussions_preview": [],
  "fetched_at": "2025-11-25T14:57:13.678988Z"
}